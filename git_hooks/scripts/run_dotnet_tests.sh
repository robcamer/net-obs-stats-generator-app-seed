#!/bin/bash

# shellcheck disable=SC1091
source "$(dirname "${BASH_SOURCE[0]}")/helpers.sh"

readonly CODE_DIR="src/edge/ntwkobsv/"
readonly TOOL_CONFIG=".config/dotnet-tools.json"
readonly COVERAGE_THRESHOLD=85
readonly MINICOVER_VERBOSITY="critical"
readonly DOTNET_VERBOSITY="q"
readonly WARNING_REGEX="[1-9]+\d? Warning"
declare TOTAL_COVERAGE=100

main() {
  local clean=false
  for i in ${1:-}; do
    case $i in
      -c|--clean)
        clean=true
        shift # past argument=value
        ;;
      -h|--help)
        usage
        ;;
      *)
        ;;
    esac
  done

  cd "$CODE_DIR" || exit 1
  print_title "Running $CODE_DIR unit test & Coverage"
  check_create_tool_manifest
  check_install_minicover_tool
  instrument_and_test
  create_coverage_reports

  if [[ true == "$clean" ]]; then clean_up; fi;

  if [[ 0 == $(echo "$TOTAL_COVERAGE"'>'$COVERAGE_THRESHOLD | bc -l) ]]; then
    echo "Coverage failed! Required coverage of $COVERAGE_THRESHOLD% not met!"
    exit 1
  fi
  exit 0
}

usage() {
  cat <<- USAGE
  Usage: $0 [-c clean] [-h help]

  Options:
    -c, --clean:  removes files generated by code coverage and unit test
    -h, --help:   display usage information
	USAGE
  exit 1
}

check_create_tool_manifest() {
  if [[ ! -f "$TOOL_CONFIG" ]]; then
    printf "\n\nCreating dotnet tool config file!\n"
    dotnet new tool-manifest
  else
    printf "\nRestoring dotnet tools!\n"
    dotnet tool restore
  fi
}

check_install_minicover_tool() {
  if (dotnet tool list | (! grep -q "minicover")); then
    echo "Installing minicover tool!"
    dotnet tool install minicover
  fi;
}

instrument_and_test() {
  dotnet clean --nologo -v "$DOTNET_VERBOSITY"

  build_output=$(dotnet build --nologo -v "$DOTNET_VERBOSITY" || exit 1)

  if [[ $build_output =~ $WARNING_REGEX ]]; then
    echo -e "$build_output \nWarning checks failed! Please address the above warning(s) before committing!"
    exit 1
  fi;

  dotnet build || exit 1

  dotnet minicover instrument -v "$MINICOVER_VERBOSITY" --sources /**/*.cs \
  --exclude-sources /**/*Program*.cs --exclude-sources /**/*Worker*.cs --exclude-sources /**/*Exception.cs

  dotnet minicover reset -v "$MINICOVER_VERBOSITY"


  for project in Test*/*.csproj; do
    (dotnet test --nologo -v "$DOTNET_VERBOSITY" --no-build "$project" --test-adapter-path:. \
      --logger:"junit;LogFilePath=../artifacts/junit/$project-test-result.xml;MethodFormat=Class;FailureBodyFormat=Verbose";) || exit 1
  done

  dotnet minicover uninstrument -v "$MINICOVER_VERBOSITY"
}

create_coverage_reports() {
  dotnet minicover htmlreport --threshold "$COVERAGE_THRESHOLD" --no-fail
  dotnet minicover coberturareport --output artifacts/cobertura.xml
  dotnet minicover report --threshold "$COVERAGE_THRESHOLD"

  if [[ ! -f "coverage.json" ]]; then
	echo "Error! Coverage reports not generated!"
	exit 1
  fi

  TOTAL_COVERAGE=$(dotnet minicover report | grep "All files"  | awk '{print $7}' | tr -d '%')
  printf "\nTOTAL_COVERAGE=%2.2f\n" "$TOTAL_COVERAGE"
}

clean_up() {
  rm -rf coverage-hits artifacts coverage.json artifacts
  find . -type d -name 'TestResults' -exec rm -rf {} +
}

main "$@"
